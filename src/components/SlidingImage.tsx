import React, { useState } from 'react';
import styled, { css } from 'styled-components';
import VisibilitySensor from 'react-visibility-sensor';

export interface SlidingImageProps {
  image: { default: string };
  imageAlt: string;
  imageStyle: React.CSSProperties | undefined;
  animationDirection: 'toRight' | 'toLeft';
  animationX?: string;
  animationRotation?: string;
}

export const SlidingImage: React.FC<SlidingImageProps> = ({
  image,
  imageAlt,
  imageStyle,
  animationDirection,
  animationX,
  animationRotation,
}) => {
  const [isVisible, setIsVisible] = useState<boolean>(false);

  return (
    <VisibilitySensor
      partialVisibility
      onChange={(isVisible: boolean) => {
        setIsVisible(isVisible);
      }}
    >
      <Image
        src={image.default}
        alt={imageAlt}
        isVisible={isVisible}
        animationDirection={animationDirection}
        animationX={animationX}
        animationRotation={animationRotation}
        style={imageStyle}
      />
    </VisibilitySensor>
  );
};

const Image = styled.img<{
  isVisible: boolean;
  animationDirection: 'toRight' | 'toLeft';
  animationX?: string;
  animationRotation?: string;
}>`
  --animationX: ${(props) => (props.animationX ? props.animationX : '100px')};
  --negativeAnimationX: calc(-1 * var(--animationX));
  --animationRotation: ${(props) =>
    props.animationRotation ? props.animationRotation : '5deg'};

  /* ----------------------------------------------
 * Generated by Animista on 2020-12-6 20:56:11
 * Licensed under FreeBSD License.
 * See http://animista.net/license for more info. 
 * w: http://animista.net, t: @cssanimista
 * ---------------------------------------------- */

  /**
 * ----------------------------------------
 * animation slide-bl
 * ----------------------------------------
 */
  @-webkit-keyframes slide-bl {
    0% {
      opacity: 0;
      -webkit-transform: translateY(0) translateX(0) rotate(0deg);
      transform: translateY(0) translateX(0) rotate(0deg);
    }
    25% {
      opacity: 0;
    }
    100% {
      opacity: 1;
      -webkit-transform: translateY(var(--animationX))
        translateX(var(--negativeAnimationX)) rotate(var(--animationRotation));
      transform: translateY(var(--animationX))
        translateX(var(--negativeAnimationX)) rotate(var(--animationRotation));
    }
  }
  @keyframes slide-bl {
    0% {
      opacity: 0;
      -webkit-transform: translateY(0) translateX(0) rotate(0deg);
      transform: translateY(0) translateX(0) rotate(0deg);
    }
    25% {
      opacity: 0;
    }
    100% {
      opacity: 1;
      -webkit-transform: translateY(var(--animationX))
        translateX(var(--negativeAnimationX)) rotate(var(--animationRotation));
      transform: translateY(var(--animationX))
        translateX(var(--negativeAnimationX)) rotate(var(--animationRotation));
    }
  }

  /* ----------------------------------------------
 * Generated by Animista on 2020-12-7 15:22:17
 * Licensed under FreeBSD License.
 * See http://animista.net/license for more info. 
 * w: http://animista.net, t: @cssanimista
 * ---------------------------------------------- */

  /**
 * ----------------------------------------
 * animation slide-br
 * ----------------------------------------
 */
  @-webkit-keyframes slide-br {
    0% {
      opacity: 0;
      -webkit-transform: translateY(0) translateX(0) rotate(0deg);
      transform: translateY(0) translateX(0) rotate(0deg);
    }
    25% {
      opacity: 0;
    }
    100% {
      opacity: 1;
      -webkit-transform: translateY(var(--animationX))
        translateX(var(--animationX)) rotate(var(--animationRotation));
      transform: translateY(var(--animationX)) translateX(var(--animationX))
        rotate(var(--animationRotation));
    }
  }
  @keyframes slide-br {
    0% {
      opacity: 0;
      -webkit-transform: translateY(0) translateX(0) rotate(0deg);
      transform: translateY(0) translateX(0) rotate(0deg);
    }
    25% {
      opacity: 0;
    }
    100% {
      opacity: 1;
      -webkit-transform: translateY(var(--animationX))
        translateX(var(--animationX)) rotate(var(--animationRotation));
      transform: translateY(var(--animationX)) translateX(var(--animationX))
        rotate(var(--animationRotation));
    }
  }

  display: none;
  opacity: 0;

  @media (min-width: 768px) {
    display: initial;
  }

  ${(props) =>
    props.isVisible &&
    props.animationDirection === 'toLeft' &&
    css`
      -webkit-animation: slide-bl 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
      animation: slide-bl 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
    `}

  ${(props) =>
    props.isVisible &&
    props.animationDirection === 'toRight' &&
    css`
      -webkit-animation: slide-br 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
      animation: slide-br 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
    `}
`;
